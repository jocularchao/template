# 前后端分离项目模板

包括登录、注册和密码重置等功能，可以二次开发编写具体场景下的应用程序

- 登录功能（支持用户名、邮箱登录）
- 注册用户（通过邮箱注册）
- 重置密码（通过邮箱重置密码）



## 后端

### 1 创建项目

#### 1.1 idea创建springboot项目

![image-20231212114023739](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114023739.png)

#### 1.2 导入依赖

![image-20231212114327333](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114327333.png)

#### 1.3 清理干净项目

![image-20231212114532378](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114532378.png)

因为是前后端分离项目，后端不涉及前端页面，所以就把static、templates删掉

![image-20231212114718804](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212114718804.png)



### 2 配置

#### 2.1 配置数据源

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/community?useUnicode=true&characterEncoding=utf-8
    username: root
    password: 123456
```

#### 2.2 配置springsecurity

##### 2.2.1 springsecurity配置类

![image-20231212165142657](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212165142657.png)

因为是前后端分离项目，所以肯定不是走springboot的服务器，要走前端的服务器

所以，我要把登陆等功能的接口单独定义出来

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                //先做权限校验，没有登录不能进入
                .authorizeHttpRequests()
                //目前没有分角色，没有其他的功能，直接所有请求全部需要验证
                .anyRequest().authenticated()
                .and()
                //配置登录接口
                .formLogin()
                .loginProcessingUrl("/api/auth/login")
                .and()
                //配置登出接口
                .logout()
                .logoutUrl("/api/auth/logout")
                .and()
                //暂时关闭csrf校验
                .csrf()
                .disable()
                .build();
        
    }
}
```

运行测试以下，密码默认生成在控制台

测试成功

![image-20231212170912069](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212170912069.png)

当前台调用了我们后端的接口之后，我们要返回一个json的数据，告诉我们登录成功了或登出成功了这样的信息

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                //先做权限校验，没有登录不能进入
                .authorizeHttpRequests()
                //目前没有分角色，没有其他的功能，直接所有请求全部需要验证
                .anyRequest().authenticated()
                .and()
                //配置登录接口
                .formLogin()
                .loginProcessingUrl("/api/auth/login")
                //登录成功后处理
                .successHandler(this::onAuthenticationSuccess)
                .and()
                //配置登出接口
                .logout()
                .logoutUrl("/api/auth/logout")
                .and()
                //暂时关闭csrf校验
                .csrf()
                .disable()
                .build();

    }

    //登录成功后，
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        //设置编码格式
        response.setCharacterEncoding("utf-8");
        response.getWriter().write("登录成功");
    }
}
```

测试成功

![image-20231212172748342](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212172748342.png)



##### 2.2.2 实体类

创建实体类RestBean接收信息，方便我们得到json数据

```java
//具体类型不知道所以要定义泛型类
@Data
public class RestBean<T> {
    //三个关键数据：

    //当前的状态
    private int status;
    //是否成功
    private boolean success;
    //返回的数据
    private T message;

    //定义私有的全参构造方法
    private RestBean( int status, boolean success,T message) {
        this.status = status;
        this.success = success;
        this.message = message;
    }

    //定义几个工具方法
    //登录成功
    public static <T> RestBean<T> success(){
        return new RestBean<>(200,true,null);
    }
    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200,true,data);
    }

    //登录失败
    public static <T> RestBean<T> failure(int status){
        return new RestBean<>(status,false,null);
    }
    public static <T> RestBean<T> failure(int status,T data){
        return new RestBean<>(status,false,data);
    }
}
```



##### 2.2.3 登录成功

在security配置类中输出实体类信息，并转换成json格式

导入fastjson依赖后

在登陆成功处输出实体类信息

```java
//登录成功后，
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
    //设置编码格式
    response.setCharacterEncoding("utf-8");
    response.getWriter().write(JSONObject.toJSONString(RestBean.success("登录成功")));
}
```

![image-20231212175802478](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212175802478.png)

> ##### 为什么要转换成json数据
>
> 因为前端需要的就是这样的数据，前端会将json直接解析，非常方便



##### 2.2.4 登录失败

在security配置类定义登录失败接口

```java
//登录失败的处理
.failureHandler(this::onAuthenticationFailure)
```

```java
//登录失败
public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
  //避免乱码
  response.setCharacterEncoding("utf-8");            		  response.getWriter().write(JSONObject.toJSONString(RestBean.failure(401,exception.getMessage())));
    
}
```

![image-20231212180940715](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212180940715.png)



##### 2.2.5 未授权

当访问的是未定义的接口，就返回未授权

此时，要在build方法前调用exceptionHandler的entrypoint方法

```java
//在未授权时会调用这个commence方法，输出失败的信息
.exceptionHandling()
.authenticationEntryPoint(this::onAuthenticationFailure)
.and()
.build();
```

![image-20231212182052006](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212182052006.png)









### 3 结构化

#### 3.1 必要依赖

##### fastjson

 将字符串转换成json的工具类

```xml
<!-- 字符串转换成json -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
    <version>2.0.43</version>
</dependency>
```

##### lombok

```xml
<!-- lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.30</version>
    <scope>provided</scope>
</dependency>
```





3.2 config配置包

config

- `SecurityConfiguration `security配置类



3.3 entity实体包

entity

- `RestBean `接收信息的实体类
- 































## 前端

### 1 创建项目

#### 1.1 webstorm创建create-vue项目

![image-20231212115824321](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212115824321.png)

#### 1.2 更新并测试运行

![image-20231212115925412](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212115925412.png)

#### 1.3 清理干净项目

```javascript
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
```

```vue
<script setup>

</script>

<template>

</template>

<style scoped>

</style>
```

![image-20231212120257781](./%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E6%9D%BF/image-20231212120257781-1702353778372-1.png)

